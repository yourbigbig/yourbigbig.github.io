<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[树莓派3代B型使用记录]]></title>
    <url>%2F2019%2F05%2F19%2Fraspberry%2Fraspberry%2F</url>
    <content type="text"><![CDATA[树莓派3代B型开发板资料地址： http://www.yahboom.com/study/raspberry密码：cf0pssh连接 pi raspberry 触摸屏配置//使用7寸触摸在/boot/config.text 追加dtparam=audio=onmax_usb_current=1hdmi_force_hotplug=1 强制树莓派使用HDMI端口config_hdmi_boost=3 范围从1（用于短电缆）到7（用于长电缆）hdmi_group=2hdmi_mode=87hdmi_cvt 1024 600 60 6 0 0 0 设置时区sudo dpkg-reconfigure tzdata 更换数据源树莓派官方有提供的镜像列表：http://www.raspbian.org/RaspbianMirrors更改 /etc/apt/sources.list 中的源地址 安装VNC远程桌面 http://www.tightvnc.com/download.php 123apt-get install tightvncserver启动 tightvncserver 输入2次密码 tightvncserver 树莓派启动 安装vim 编辑器123apt-get update apt-get upgradeapt-get vim Vim有一个带图形界面的版本，可以分别安装。这个版本打开一个支持鼠标操作的新窗口1apt-get install vim-gnome //设置WIFI /etc/wpa_/wpa_添加12345678country=CNnetwork=&#123; ssid=&quot;sss&quot; psk=&quot;mmmm&quot; key_mgmt=WPA-PSK priority=2 #连接优先级，数字越大优先级越高（不可以是负数） # scan_ssid=0 连接隐藏WiFi时需要指定该值为1&#125; /etc/network/interfaces 开机启动 /etc/rc.local scim 启动输入法 支持库安装 一 安装Wiring http://www.waveshare.net/study/article-742-1.html 通过GIT获得wiringPi的源码 1231 git clone git://git.drogon.net/wiringPi2 cd wiringPi3 ./build 解压 1231tar -zxvf wiringPi-xxx.tar.gz2cd wiringPi3./build 二 安装BCM2583从bcm22835官网下载最新版本的库，然后解压安装。123456tar -zxvf bcm2835-1.xx.tar.gzcd bcm2835-1.xx./configuremakesudo make checksudo make install 三、python1、安装RPi.GPIO（1）先安装python-dev,输入以下指令。 sudo apt-get install python-dev（2）安装RPi.GPIO和spidev，先下载安装包（RPi.GPIO安装包和spidev安装包， 参见：https://pypi.python.org/pypi/RPi.GPIOhttps://pypi.python.org/pypi/spidev ）， 然后通过samba等方式把下载好的文件解压到树莓派上。 四 串口SPI 等等https://www.cnblogs.com/lulipro/p/5992172.html Python 支持库 /root/wpi BCM / 内核模块编译参考启动系统后，输入命令uname -a,可以得到输出： Linux raspberrypi 4.4.34-v7+ #930 SMP Wed Nov 23 15:20:41 GMT 2016 armv7l GNU/Linux 可以知道linux版本是4.4.34-v7+。 编译内核模块需要kernel-headers。输入命令sudo apt-cache search kernel-headers，搜索合适的kernel-headers。结果如下： raspberrypi-kernel-headers - Header files for the Raspberry Pi Linux kernel 输入命令 sudo apt-get install raspberrypi-kernel-headers，下载安装树莓派kernel-headers。 安装成功后可以在/usr/src目录下生成两个文件夹linux-headers-4.4.34+ 和 linux-headers-4.4.34-v7+， 我们需要使用 linux-headers-4.4.34-v7+。 做make menuconfig时没有看到上面的画面，而是看到一堆英文，则一般是没有安装libncurses5-dev开发库，使用apt-get install libncurses5-dev来安装就行了下面是编写模块源码，如下： 12345678910111213141516#include &lt;linux/init.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;static int hello_init(void)&#123; printk(&quot;Hi,raspi linux kernel，i am a hello world module.\n&quot;); return 0;&#125;static void hello_exit(void)&#123; printk(&quot;Goodbye,raspi linux kernel.\n&quot;);&#125;module_init(hello_init);module_exit(hello_exit);MODULE_LICENSE(&quot;GPL&quot;); 接着编写Makefile，内容如下： 123456KERNEL_DIR:=/usr/src/linux-headers-4.4.34-v7+obj-m:=hello.odefault: $(MAKE) -C $(KERNEL_DIR) SUBDIRS=$(PWD) modulesclean: $(RM) .*.cmd *.mod.c *.o *.ko -r .tmp 输入make命令编译后，生成内核模块文件hello.ko。输入sudo insmod hello.ko安装模块。输入sudo rmmod hello卸载模块。尝试安装和卸载，输入dmesg命令可以在末尾看到：[ 5137.447586] Hi,raspi linux kernel，i am a hello world module.[ 5157.380482] Goodbye, raspi linux kernel. 证明模块安装和卸载成功。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>raspberry</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python笔记 v1.0]]></title>
    <url>%2F2019%2F05%2F19%2Fpython%2Fpython%2F</url>
    <content type="text"><![CDATA[[toc] Python-Tkinter几何布局管理（转）单选框打包exe 0 原始转图样例1234567891011import osimg_path = r&quot;F:\tools\raw2bmp-IR\Data&quot;imgs = []for root, dirs, files in os.walk(img_path): for file in files: if os.path.splitext(file)[1] == &quot;.raw&quot;: imgs.append(os.path.join(root, file))for img in imgs: print(r&quot;.\raw_to_bmp_node.exe --img_fname=%s --width=%d --height=%d&quot; % (img, 640, 480)) os.system(r&quot;.\raw_to_bmp_node.exe --img_fname=%s --width=%d --height=%d&quot; % (img, 640, 480)) 1 遍历文件夹要取得该文件夹下的所有文件，可以使用for (root, dirs, files) in walk(roots)函数。roots代表需要遍历的根文件夹root表示正在遍历的文件夹的名字（根/子）dirs记录正在遍历的文件夹下的子文件夹集合files记录正在遍历的文件夹中的文件集合123456for root, dir, file in os.walk(r&quot;E:\360MoveData\Users\yangjunwei\Desktop\Python_test&quot;): print(root) print(dir) print(file) a = a+1 print(&quot;循环次数:&quot;,a) 2 获取当前路径 使用sys.argv[0] 1234import sysprint sys.argv[0]#输出#本地路径 os模块import osprint os.getcwd() #获取当前工作目录路径print os.path.abspath(‘.’) #获取当前工作目录路径print os.path.abspath(‘test.txt’) #获取当前目录文件下的工作目录路径print os.path.abspath(‘..’) #获取当前工作的父目录 ！注意是父目录路径print os.path.abspath(os.curdir) #获取当前工作目录路径 3 格式化输出12345a = 22b = 33print(&quot;a = &quot;,a) 输出 a = 22print(&quot;a =%d&quot;%a) 输出 a = 22print(&quot;a = %d,b= %d&quot;%(a,b)) 输出 a = 22 4 文件内容修改替换操作当我们读取文件中内容后，如果想要修改文件中的某一行或者某一个位置的内容，在python中是没有办法直接实现的，如果想要实现这样的操作只能先把文件所有的内容全部读取出来，然后进行匹配修改后写入到新的文件中。实例代码如下所示： # 打开旧文件f = open(‘file_text.txt’,’r’,encoding=’utf-8’)、# 打开新文件f_new = open(‘file_text_bak.txt’,’w’,encoding=’utf-8’) # 循环读取旧文件for line in f: # 进行判断 if &quot;Good day is good day&quot; in line: line = line.replace(&apos;Good day is good day&apos;,&apos;hello,yanyan&apos;) # 如果不符合就正常的将文件中的内容读取并且输出到新文件中 f_new.write(line) f.close()f_new.close() 5 开启库手册服务python -m pydoc -p 8888 6 讲上级目录的的raw生成bmp（例）123456789101112131415161718192021222324252627282930# -*- coding: utf-8 -*-import osimport shutilimg_path = os.path.abspath('..')result_path = img_path+"\\raw\\"imgs = []old_pic = []for root, dirs, files in os.walk(result_path): for file in files: if os.path.splitext(file)[1] == ".raw": print("2"+file) os.remove(os.path.join(root, file))#删除文件for root, dirs, files in os.walk(img_path): for file in files: if os.path.splitext(file)[1] == ".raw": imgs.append(os.path.join(root, file)) print("0"+file) if os.path.splitext(file)[1] == ".bmp": os.remove(os.path.join(root, file)) print("1"+file)for img in imgs: print(r".\raw_to_bmp_node.exe --img_fname=%s --width=%d --height=%d" % (img, 1280, 800)) os.system(r".\raw_to_bmp_node.exe --img_fname=%s --width=%d --height=%d" % (img, 1280, 800)) shutil.move(img, result_path+os.path.basename(img)) #os.remove(img) 7 python 读写、创建 文件python中对文件、文件夹（文件操作函数）的操作需要涉及到os模块和shutil模块。 得到当前工作目录，即当前Python脚本工作的目录路径: os.getcwd() 返回指定目录下的所有文件和目录名:os.listdir() 函数用来删除一个文件:os.remove() 删除多个目录：os.removedirs（r“c：\python”） 检验给出的路径是否是一个文件：os.path.isfile() 检验给出的路径是否是一个目录：os.path.isdir() 判断是否是绝对路径：os.path.isabs() 检验给出的路径是否真地存:os.path.exists() 返回一个路径的目录名和文件名:os.path.split() eg os.path.split(‘/home/swaroop/byte/code/poem.txt’) 结果：(‘/home/swaroop/byte/code’, ‘poem.txt’) 分离扩展名：os.path.splitext() 获取路径名：os.path.dirname() 获取文件名：os.path.basename() 运行shell命令: os.system() 读取和设置环境变量:os.getenv() 与os.putenv() 给出当前平台使用的行终止符:os.linesep Windows使用’\r\n’，Linux使用’\n’而Mac使用’\r’ 指示你正在使用的平台：os.name 对于Windows，它是’nt’，而对于Linux/Unix用户，它是’posix’ 重命名：os.rename（old， new） 创建多级目录：os.makedirs（r“c：\python\test”） 创建单个目录：os.mkdir（“test”） 获取文件属性：os.stat（file） 修改文件权限与时间戳：os.chmod（file） 终止当前进程：os.exit（） 获取文件大小：os.path.getsize（filename） 文件操作：os.mknod(“test.txt”) 创建空文件fp = open(“test.txt”,w) 直接打开一个文件，如果文件不存在则创建文件 关于open 模式： w 以写方式打开，a 以追加模式打开 (从 EOF 开始, 必要时创建新文件)r+ 以读写模式打开w+ 以读写模式打开 (参见 w )a+ 以读写模式打开 (参见 a )rb 以二进制读模式打开wb 以二进制写模式打开 (参见 w )ab 以二进制追加模式打开 (参见 a )rb+ 以二进制读写模式打开 (参见 r+ )wb+ 以二进制读写模式打开 (参见 w+ )ab+ 以二进制读写模式打开 (参见 a+ ) fp.read([size]) #size为读取的长度，以byte为单位 fp.readline([size]) #读一行，如果定义了size，有可能返回的只是一行的一部分 fp.readlines([size]) #把文件每一行作为一个list的一个成员，并返回这个list。其实它的内部是通过循环调用readline()来实现的。如果提供size参数，size是表示读取内容的总长，也就是说可能只读到文件的一部分。 fp.write(str) #把str写到文件中，write()并不会在str后加上一个换行符 fp.writelines(seq) #把seq的内容全部写到文件中(多行一次性写入)。这个函数也只是忠实地写入，不会在每行后面加上任何东西。 fp.close() #关闭文件。python会在一个文件不用后自动关闭文件，不过这一功能没有保证，最好还是养成自己关闭的习惯。 如果一个文件在关闭后还对其进行操作会产生ValueError fp.flush() #把缓冲区的内容写入硬盘 fp.fileno() #返回一个长整型的”文件标签“ fp.isatty() #文件是否是一个终端设备文件（unix系统中的） fp.tell() #返回文件操作标记的当前位置，以文件的开头为原点 fp.next() #返回下一行，并将文件操作标记位移到下一行。把一个file用于for … in file这样的语句时，就是调用next()函数来实现遍历的。 fp.seek(offset[,whence]) #将文件打操作标记移到offset的位置。这个offset一般是相对于文件的开头来计算的，一般为正数。但如果提供了whence参数就不一定了，whence可以为0表示从头开始计算，1表示以当前位置为原点计算。2表示以文件末尾为原点进行计算。需要注意，如果文件以a或a+的模式打开，每次进行写操作时，文件操作标记会自动返回到文件末尾。 fp.truncate([size]) #把文件裁成规定的大小，默认的是裁到当前文件操作标记的位置。如果size比文件的大小还要大，依据系统的不同可能是不改变文件，也可能是用0把文件补到相应的大小，也可能是以一些随机的内容加上去。 目录操作：os.mkdir(“file”) 创建目录复制文件：shutil.copyfile(“oldfile”,”newfile”) oldfile和newfile都只能是文件shutil.copy(“oldfile”,”newfile”) oldfile只能是文件夹，newfile可以是文件，也可以是目标目录复制文件夹：shutil.copytree(“olddir”,”newdir”) olddir和newdir都只能是目录，且newdir必须不存在重命名文件（目录）os.rename(“oldname”,”newname”) 文件或目录都是使用这条命令移动文件（目录）shutil.move(“oldpos”,”newpos”)删除文件os.remove(“file”)删除目录os.rmdir(“dir”)只能删除空目录shutil.rmtree(“dir”) 空目录、有内容的目录都可以删转换目录os.chdir(“path”) 换路径 Python读写文件1.open使用open打开文件后一定要记得调用文件对象的close()方法。比如可以用try/finally语句来确保最后能关闭文件。 file_object = open(‘thefile.txt’)try: all_the_text = file_object.read( )finally: file_object.close( ) 注：不能把open语句放在try块里，因为当打开文件出现异常时，文件对象file_object无法执行close()方法。 2.读文件123456789101112131415161718192021222324252627282930313233读文本文件input = open(&apos;data&apos;, &apos;r&apos;)#第二个参数默认为rinput = open(&apos;data&apos;) 读二进制文件input = open(&apos;data&apos;, &apos;rb&apos;)读取所有内容file_object = open(&apos;thefile.txt&apos;)try: all_the_text = file_object.read( )finally: file_object.close( )读固定字节file_object = open(&apos;abinfile&apos;, &apos;rb&apos;)try: while True: chunk = file_object.read(100) if not chunk: break do_something_with(chunk)finally: file_object.close( )读每行list_of_all_the_lines = file_object.readlines( )如果文件是文本文件，还可以直接遍历文件对象获取每行：for line in file_object: process line 3.写文件写文本文件output = open(‘data’, ‘w’) 写二进制文件output = open(‘data’, ‘wb’) 追加写文件output = open(‘data’, ‘w+’) 写数据file_object = open(‘thefile.txt’, ‘w’)file_object.write(all_the_text)file_object.close( ) 写入多行file_object.writelines(list_of_text_strings) 注意，调用writelines写入多行在性能上会比使用write一次性写入要高。 在处理日志文件的时候，常常会遇到这样的情况：日志文件巨大，不可能一次性把整个文件读入到内存中进行处理，例如需要在一台物理内存为 2GB 的机器上处理一个 2GB 的日志文件，我们可能希望每次只处理其中 200MB 的内容。在 Python 中，内置的 File 对象直接提供了一个 readlines(sizehint) 函数来完成这样的事情。以下面的代码为例： file = open(‘test.log’, ‘r’)sizehint = 209715200 # 200Mposition = 0lines = file.readlines(sizehint)while not file.tell() - position &lt; 0: position = file.tell() lines = file.readlines(sizehint) 每次调用 readlines(sizehint) 函数，会返回大约 200MB 的数据，而且所返回的必然都是完整的行数据，大多数情况下，返回的数据的字节数会稍微比 sizehint 指定的值大一点（除最后一次调用 readlines(sizehint) 函数的时候）。通常情况下，Python 会自动将用户指定的 sizehint 的值调整成内部缓存大小的整数倍。 file在python是一个特殊的类型，它用于在python程序中对外部的文件进行操作。在python中一切都是对象，file也不例外，file有file的方法和属性。下面先来看如何创建一个file对象： file(name[, mode[, buffering]])file()函数用于创建一个file对象，它有一个别名叫open()，可能更形象一些，它们是内置函数。来看看它的参数。它参数都是以字符串的形式传递的。name是文件的名字。mode是打开的模式，可选的值为r w a U，分别代表读（默认） 写 添加支持各种换行符的模式。用w或a模式打开文件的话，如果文件不存在，那么就自动创建。此外，用w模式打开一个已经存在的文件时，原有文件的内容会被清空，因为一开始文件的操作的标记是在文件的开头的，这时候进行写操作，无疑会把原有的内容给抹掉。由于历史的原因，换行符在不同的系统中有不同模式，比如在 unix中是一个\n，而在windows中是‘\r\n’，用U模式打开文件，就是支持所有的换行模式，也就说‘\r’ ‘\n’ ‘\r\n’都可表示换行，会有一个tuple用来存贮这个文件中用到过的换行符。不过，虽说换行有多种模式，读到python中统一用\n代替。在模式字符的后面，还可以加上+ b t这两种标识，分别表示可以对文件同时进行读写操作和用二进制模式、文本模式（默认）打开文件。buffering如果为0表示不进行缓冲;如果为1表示进行“行缓冲“;如果是一个大于1的数表示缓冲区的大小，应该是以字节为单位的。 file对象有自己的属性和方法。先来看看file的属性。 closed #标记文件是否已经关闭，由close()改写encoding #文件编码mode #打开模式name #文件名newlines #文件中用到的换行模式，是一个tuplesoftspace #boolean型，一般为0，据说用于print file的读写方法： 12345678910111213141516171819202122232425262728F.read([size]) #size为读取的长度，以byte为单位 F.readline([size]) #读一行，如果定义了size，有可能返回的只是一行的一部分 F.readlines([size]) #把文件每一行作为一个list的一个成员，并返回这个list。其实它的内部是通过循环调用readline()来实现的。如果提供size参数，size是表示读取内容的总长，也就是说可能只读到文件的一部分。 F.write(str) #把str写到文件中，write()并不会在str后加上一个换行符 F.writelines(seq) #把seq的内容全部写到文件中。这个函数也只是忠实地写入，不会在每行后面加上任何东西。 file的其他方法：F.close() #关闭文件。python会在一个文件不用后自动关闭文件，不过这一功能没有保证，最好还是养成自己关闭的习惯。如果一个文件在关闭后还对其进行操作会产生ValueError F.flush() #把缓冲区的内容写入硬盘 F.fileno() #返回一个长整型的”文件标签“ F.isatty() #文件是否是一个终端设备文件（unix系统中的） F.tell() #返回文件操作标记的当前位置，以文件的开头为原点 F.next() #返回下一行，并将文件操作标记位移到下一行。把一个file用于for ... in file这样的语句时，就是调用next()函数来实现遍历的。 F.seek(offset[,whence]) #将文件打操作标记移到offset的位置。这个offset一般是相对于文件的开头来计算的，一般为正数。但如果提供了whence参数就不一定了，whence可以为0表示从头开始计算，1表示以当前位置为原点计算。2表示以文件末尾为原点进行计算。需要注意，如果文件以a或a+的模式打开，每次进行写操作时，文件操作标记会自动返回到文件末尾。 F.truncate([size]) #把文件裁成规定的大小，默认的是裁到当前文件操作标记的位置。如果size比文件的大小还要大，依据系统的不同可能是不改变文件，也可能是用0把文件补到相应的大小，也可能是以一些随机的内容加上去。 http://www.cnblogs.com/allenblogs/archive/2010/09/13/1824842.html http://www.cnblogs.com/rollenholt/archive/2012/04/23/2466179.html 收获不会与付出成反比 by juandx 8Python 截取字符串使用 变量[头下标:尾下标]，就可以截取相应的字符串，其中下标是从0开始算起，可以是正数或负数，下标可以为空表示取到头或尾。 123456789101112131415161718192021222324252627282930313233例1：字符串截取str = '12345678'print str[0:1]&gt;&gt; 1 # 输出str位置0开始到位置1以前的字符print str[1:6] &gt;&gt; 23456 # 输出str位置1开始到位置6以前的字符num = 18str = '0000' + str(num) # 合并字符串print str[-5:] # 输出字符串右5位&gt;&gt; 00018 Python 替换字符串使用 变量.replace("被替换的内容"，"替换后的内容"[，次数])，替换次数可以为空，即表示替换所有。要注意的是使用replace替换字符串后仅为临时变量，需重新赋值才能保存。#例2：字符串替换str = 'akakak'str = str.replace('k',' 8') # 将字符串里的k全部替换为8print str&gt;&gt; 'a8a8a8' # 输出结果Python 查找字符串使用 变量.find("要查找的内容"[，开始位置，结束位置])，开始位置和结束位置，表示要查找的范围，为空则表示查找所有。查找到后会返回位置，位置从0开始算，如果每找到则返回-1。#例3：字符串查找str = 'a,hello'print str.find('hello') # 在字符串str里查找字符串hello&gt;&gt; 2 # 输出结果Python 分割字符串使用 变量.split("分割标示符号"[分割次数])，分割次数表示分割最大次数，为空则分割所有。例4：字符分割str = 'a,b,c,d'strlist = str.split(',') # 用逗号分割str字符串，并保存到列表for value in strlist: # 循环输出列表值 print value&gt;&gt; a # 输出结果&gt;&gt; b&gt;&gt; c&gt;&gt; d =============================================================================== 123456789101112131415161718192021222324mport tkinter.filedialog as tkFDdef __init__(self, root): self.ext1 = Button(self.frame[1], text="选择文件", command=self.openfile,width = 10) self.ext1.pack(side = LEFT, padx = 2,pady = 10) self.txt = Text(self.frame[1],height = 1,width = 80) self.txt.pack(side = LEFT, padx = 2,pady = 10) self.ext3 = Button(self.frame[3], text="选择根目录", command=self.opendir,width = 10) self.ext3.pack(side = LEFT, padx = 2,pady = 10) self.path = Text(self.frame[3],height = 1,width = 40) self.path.pack(side = LEFT, padx = 2,pady = 10)def openfile(self): self.filename=tkFD.askopenfilename(filetypes=[("Excel 工作簿", ".xls")]) self.txt.delete(1.0,END) self.txt.insert(1.0,self.filename) def opendir(self): self.pathname=tkFD.askdirectory() self.path.delete(1.0,END) self.path.insert(1.0,self.pathname) 9 打包exe1pyinstaller -F tools2.py --noconsole 或者 1pyinstaller -F -w example.py 直接打包： 1pyinstaller -F -w example.py 10result = os.popen(‘ps aux’) res = result.read() for line in res.splitlines(): print line 11 配置文件inihttps://blog.csdn.net/zhusongziye/article/details/80024530https://blog.csdn.net/energysober/article/details/80684200 #12 读写excel https://www.cnblogs.com/shaosks/p/6098282.htmlhttps://www.cnblogs.com/lingwang3/p/6416023.html TK颜色https://blog.csdn.net/Gordennizaicunzai/article/details/81148670http://www.qhscript.com/index.php?c=article&amp;id=299https://blog.csdn.net/lqxkj628/article/details/76541287 #TK Text https://blog.csdn.net/sinat_41104353/article/details/79307111]]></content>
      <tags>
        <tag>bat, 自学 ，教程 ，笔记 ,伟伟✌</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F05%2F19%2Fother%2F%E6%9D%82%E8%AE%B0%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F05%2F19%2Fnote%2FOpencv%2FEnglish_note%2F</url>
    <content type="text"><![CDATA[2019年3月9日 00点45分 杨军伟英语笔记 菜单@param m Array that (as a whole or partly) is assigned to the constructed matrix. No data is copied by these constructors. Instead, the header pointing to m data or its sub-array is constructed and associated with it. The reference counter, if any, is incremented. So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of m . If you want to have an independent copy of the sub-array, use Mat::clone() . @param ranges Array of selected ranges of m along each dimensionality. assigned： 指定 constructed vt. 构造，建造；创立，构筑；搭建（construct的过去分词）更多释义 matrix 美 /‘metrɪks/ n. [数] 矩阵；模型；[生物][地质] 基质；母体；子宫；[地质] 脉石 复数matrices或matrixes sub-array 子阵 reference 英 /‘ref(ə)r(ə)ns/ 美 /‘rɛfrəns/ n. 参考，参照；涉及，提及；参考书目；介绍信；证明书 vi. 引用 vt. 引用 过去式referenced 过去分词referenced 现在分词referencing counter 英 /‘kaʊntə/ 美 /‘kaʊntɚ/ n. 柜台；对立面；计数器；（某些棋盘游戏的）筹码 vt. 反击，还击；反向移动，对着干；反驳，回答 vi. 逆向移动，对着干；反驳 adj. 相反的 adv. 反方向地；背道而驰地 if any 若有的话；即便要 increment 英 /‘ɪŋkrɪm(ə)nt/ 美 /‘ɪŋkrəmənt/ n. [数] 增量；增加；增额；盈余 modify 英 /‘mɒdɪfaɪ/ 美 /‘mɑdɪfaɪ/ vt. 修改，修饰；更改 vi. 修改 过去式modified 过去分词modified 现在分词modifying corresponding 英 /,kɒrɪ’spɒndɪŋ/ 美 /,kɔrə’spɑndɪŋ/ adj. 相当的，相应的；一致的；通信的 v. 类似（correspond的ing形式）；相配 elements 英 美 /ˈɛləmənts/ n. 基础；原理@param vec STL vector whose elements form the matrix. The matrix has a single column and the number of rows equal to the number of vector elements. Type of the matrix matches the type of vector elements. The constructor can handle arbitrary types, for which there is a properly declared DataType . This means that the vector elements must be primitive numbers or uni-type numerical tuples of numbers. Mixed-type structures are not supported. The corresponding constructor is explicit. Since STL vectors are not automatically converted to Mat instances, you should write Mat(vec) explicitly. Unless you copy the data into the matrix ( copyData=true ), no new elements will be added to the vector because it can potentially yield vector data reallocation, and, thus, the matrix data pointer will be invalid. @param copyData Flag to specify whether the underlying data of the STL vector should be copied to (true) or shared with (false) the newly constructed matrix. When the data is copied, the allocated buffer is managed using Mat reference counting mechanism. While the data is shared, the reference counter is NULL, and you should not deallocate the data until the matrix is not destructed. vector 英 /&apos;vektə/ 美 /&apos;vɛktɚ/ n. 矢量；带菌者；航线 vt. 用无线电导航 这里应该是 迭代器 stl abbr. 标准模板库（Standard Template Library） single 英 /&apos;sɪŋg(ə)l/ 美 /&apos;sɪŋɡl/ adj. 单一的；单身的；单程的 n. 一个；单打；单程票 vt. 选出 vi. 击出一垒安打 过去式singled 过去分词singled 现在分词singling column 英 /&apos;kɒləm/ 美 /&apos;kɑləm/ n. 纵队，列；专栏；圆柱，柱形物 arbitrary 英 /&apos;ɑːbɪt(rə)rɪ/ 美 /ˈɑːrbətreri/ adj. [数] 任意的；武断的；专制的 declared 英 /dɪ&apos;kleəd/ 美 /dɪ&apos;klɛrd/ adj. 公然的；公开宣布的 Unnormalized box filter is useful for computing various integral characteristics over each pixelneighborhood, such as covariance matrices of image derivatives (used in dense optical flowalgorithms, and so on). If you need to compute pixel sums over variable-size windows, use cv::integral. Unnormalized非规格化]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F05%2F19%2Fjekyll%2Fnote_jekyll%2F</url>
    <content type="text"><![CDATA[1 Jekyll中文网Liquid语法:https://help.shopify.com/themes/liquid Jekyll中文网:http://jekyll.com.cn/ Git官网:https://git-scm.com/ hexo new page about &lt;% if (site.tags.length){ %&gt; About 邮箱：xxx@xxx.com 微博：@xxxxx &lt;% } %&gt; https://github.com/yscoder/hexo-theme-indigo/wiki/ 修改宽度：variable.lessline 28 :: @contentWidth: 1480px; layout.less line 131 :: @contentWidth 140–172]]></content>
  </entry>
  <entry>
    <title><![CDATA[测试总结]]></title>
    <url>%2F2019%2F05%2F19%2FTEST%2FTest_note%2F</url>
    <content type="text"><![CDATA[一、测试思想 二、测试原则 三、测试模型1.瀑布模型 2.V、W模型 四、测试组流程（测试提供） 五、测试方法 1.按阶段划分 2.静态测试、动态测试 3.黑盒、白盒、灰盒测试 4.人工测试、自动化测试 5.非功能测试 6.其他测试 六、产品测试 测试用例模板 七、测试用例编写 八、研发自测 总结 附件 敏捷开发.xmind 测试方法.xmind 测试体系.xmind]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Opencv笔记 v1.0]]></title>
    <url>%2F2019%2F05%2F19%2FOpencv_note%2F</url>
    <content type="text"><![CDATA[[toc] 2019年3月8日21点48分 杨军伟学习笔记 菜单 一、下载Opencv 1、官网下载（测试部分无法运行） 巨慢 2、https://opencv.org/releases.html 3、（3.2以下版本）https://blog.csdn.net/love666666shen/article/details/76449155 4、cmake下载：https://cmake.org/download/ 二、安装Opencv 一、添加环境变量：目录\opencv\build\x86\vc11\bin 或者目录\opencv\build\x64\vc11\bin 二、在【通用属性】 -&gt;【VC++目录】 -&gt;【包含目录】中 添加： 目录\opencv\build\include 目录\opencv\build\include\opencv 目录\opencv\build\include\opencv2 三、工程库（lib）目录的配置 【VC++目录】 -&gt;【库目录】中 添加： 目录\opencv\build\x86(64)\vc11\lib 四、添加依赖库 在【链接器】-&gt;【常规】-&gt;【附加库目录】选择lib目录 如：目录\opencv\build\x64\vc14\lib 在【链接器】-&gt;【输入】-&gt;【附加依赖项】中添加库文件名称(带’d’的时DEbug中用的)opencv_world320.lib opencv_world320d.lib1、OpenCV 3.2.0附加依赖项库 网上找的不能用 解决方法：到安装目录\opencv\build\x64\vc14\lib 找到对应的lib文件添加，我只找到目录下的2个 添加暂时可运行（后续验证就是这两个就行） 2、由于找不到 opencv_world320.dll，无法继续执行代 解决方法：到安装目录\opencv\build\x64\vc14\bin 复制里面的dll文件到 C:\Windows\System32 （x64） C:\Windows\SysWOW64 （x86）32位系统 五、其他情况不安全代码 将宏添加到 【c/c++】-&gt;【预处理器】-&gt;【预处理器定义中】 测试代码：//图片放在项目的二级目录下 #include &lt;opencv2/opencv.hpp&gt; using namespace cv; int main(void) {Mat img=imread(&quot;1.jpg&quot;); imshow(&quot;test&quot;,img); waitKey(5000); } 图片打开成功三、一般类与函数 1、Mat类2、imread 读取图片，指定读取的颜色方式。 3、imshow 在指定名称的窗口显示指定图片 4、namedWindow 创建窗口 5、imwrite 向文件中写入一张图片 6、VideoCapture 类：对视频进行读取显示，以及调用摄像头。 7、定义ROI的两种方法 1、Mat类用于保存图像以及其他矩阵数据的数据结构，默认情况下其尺寸为0. 2、imread//读数据CV_EXPORTS_W Mat imread( const String&amp; filename, int flags = IMREAD_COLOR ); 读取图片，指定读取的颜色方式。 filename：路径名 flags： 载入标识，指定加载图像的颜色类型， 默认是1，返回彩色图像， 为0时 返回灰度图像。 读取路径格式说明：https://blog.csdn.net/xingchenbingbuyu/article/details/513750781234567891011121314151617181920212223int main(int argc,char* argv[])&#123; Mat img;//以下六种合法 //-- 1 --双右斜线法 //string imgpath = "C:\\Users\\bingbuyu\\Pictures\\photo\\miao1.jpg"; //-- 2 --双左斜线法 //string imgpath = "C://Users//bingbuyu//Pictures//photo//miao1.jpg"; //-- 3 --单左斜线法 //string imgpath = "C:/Users/bingbuyu/Pictures/photo/miao1.jpg"; //-- 4 --以上三种混合法 //string imgpath = "C:/Users//bingbuyu\\Pictures//photo//miao1.jpg"; //-- 5 --相对路径法 //string imgpath = "miao.jpg"; //-- 6 --命令行参数法 string imgpath = argv[1]; img = imread(imgpath, 1); imshow("img", img); waitKey(0); return 0;&#125; 3、imshow//显示CV_EXPORTS_W void imshow(const String&amp; winname, InputArray mat); 在指定名称的窗口显示指定图片 winname：显示的窗口名称。 mat: 显示的图像。 4、 namedWindow//创建窗口CV_EXPORTS_W void namedWindow(const String&amp; winname, int flags = WINDOW_AUTOSIZE); winname: 窗口名称（与imread中的参数1名称一致时，则imread使用该窗口） flags ： 显示方式 WINDOW_NORMAL = 0x00000000, //!&lt; the user can resize the window (no constraint) / also use to switch a fullscreen window to a normal size. WINDOW_AUTOSIZE = 0x00000001, //!&lt; the user cannot resize the window, the size is constrainted by the image displayed. WINDOW_OPENGL = 0x00001000, //!&lt; window with opengl support. WINDOW_FULLSCREEN = 1, //!&lt; change the window to fullscreen. WINDOW_FREERATIO = 0x00000100, //!&lt; the image expends as much as it can (no ratio constraint). WINDOW_KEEPRATIO = 0x00000000, //!&lt; the ratio of the image is respected. WINDOW_GUI_EXPANDED=0x00000000, //!&lt; status bar and tool bar WINDOW_GUI_NORMAL = 0x00000010, //!&lt; old fashious way 5、向文件中写入一张图片。 CV_EXPORTS_W bool imwrite( const String&amp; filename, InputArray img, const std::vector&lt;int&gt;&amp; params = std::vector&lt;int&gt;()); 向文件中写入一张图片。 filename：图片的名字，带后缀。支持转换成不同的格式。 img :mat格式的图像。 6、对视频进行读取显示，以及调用摄像头。 VideoCapture 类： (1)先实例再初始化 VideoCapture capture; capture.open(&quot;1.avi&quot;); //摄像头：capture.open(0); (2) 实例的同时进行初始化 VideoCapture capture(&quot;1.avi&quot;); //摄像头： VideoCapture capture(0); while(1) { Mat frame; //定义一个Mat变量，用于存储每一帧的图像 captrue&gt;&gt;frame; //读取当前帧 imshow(&quot;test&quot;,frame); waitKey(33); } 7、定义ROI的两种方法 (1)使用Rect，指定矩形的左上角坐标和矩形的长宽，定义一个矩形区域。 Mat iamgrROI = Image(Rect(x,y,xleng,yleng)); (2)使用Range 指定 Mat iamgrROI = Image(Range(500,500+xleng),Range(250,+yleng)); 列子： Mat img1 = imread(“1.jpg”); Mat img2 = imread(“2.jpg”); Mat mask = imread(“2.jpg”); Mat frameROI = img1(Rect(10, 20, img2.cols, img2.rows)); img2.copyTo(frameROI, mask); imshow(“ROI”,img1); waitKey(3000); 8、图像的线性混合(两张图片大小一致)Mat result_img; double alpha = 0.5; double beta = (1 - alpha); addWeighted(img1,alpha,img2,beta,0.0,result_img); imshow(&quot;线性混合效果图&quot;, result_img); 9、滑动条的使用const int G_maxalpha_value_Slider = 100; int G_AlphaValue_Slider=50; double G_AlphaValue; double G_betaValue; #define WINDOW_NAME &quot;线性混合&quot; Mat img_1= imread(&quot;2.jpg&quot;); Mat img_2= imread(&quot;3.jpg&quot;); Mat img_result; void on_Trackbar(int) { G_AlphaValue = (double)G_AlphaValue_Slider / G_maxalpha_value_Slider; G_AlphaValue = 1.0 - G_AlphaValue; addWeighted(img_1, G_AlphaValue, img_2, G_AlphaValue, 0.0, img_result); imshow(WINDOW_NAME, img_result); } //mian()中 namedWindow(WINDOW_NAME); cvCreateTrackbar(&quot;bar&quot;, WINDOW_NAME,&amp;G_AlphaValue_Slider,G_maxalpha_value_Slider, on_Trackbar); on_Trackbar(G_AlphaValue_Slider);]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试]]></title>
    <url>%2F2019%2F05%2F19%2F%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[python笔记 v1.0]]></title>
    <url>%2F2019%2F05%2F19%2Fpython%2F</url>
    <content type="text"><![CDATA[[toc] Python-Tkinter几何布局管理（转）单选框打包exe 0 原始转图样例1234567891011import osimg_path = r&quot;F:\tools\raw2bmp-IR\Data&quot;imgs = []for root, dirs, files in os.walk(img_path): for file in files: if os.path.splitext(file)[1] == &quot;.raw&quot;: imgs.append(os.path.join(root, file))for img in imgs: print(r&quot;.\raw_to_bmp_node.exe --img_fname=%s --width=%d --height=%d&quot; % (img, 640, 480)) os.system(r&quot;.\raw_to_bmp_node.exe --img_fname=%s --width=%d --height=%d&quot; % (img, 640, 480)) 1 遍历文件夹要取得该文件夹下的所有文件，可以使用for (root, dirs, files) in walk(roots)函数。roots代表需要遍历的根文件夹root表示正在遍历的文件夹的名字（根/子）dirs记录正在遍历的文件夹下的子文件夹集合files记录正在遍历的文件夹中的文件集合123456for root, dir, file in os.walk(r&quot;E:\360MoveData\Users\yangjunwei\Desktop\Python_test&quot;): print(root) print(dir) print(file) a = a+1 print(&quot;循环次数:&quot;,a) 2 获取当前路径 使用sys.argv[0] 1234import sysprint sys.argv[0]#输出#本地路径 os模块import osprint os.getcwd() #获取当前工作目录路径print os.path.abspath(‘.’) #获取当前工作目录路径print os.path.abspath(‘test.txt’) #获取当前目录文件下的工作目录路径print os.path.abspath(‘..’) #获取当前工作的父目录 ！注意是父目录路径print os.path.abspath(os.curdir) #获取当前工作目录路径 3 格式化输出12345a = 22b = 33print(&quot;a = &quot;,a) 输出 a = 22print(&quot;a =%d&quot;%a) 输出 a = 22print(&quot;a = %d,b= %d&quot;%(a,b)) 输出 a = 22 4 文件内容修改替换操作当我们读取文件中内容后，如果想要修改文件中的某一行或者某一个位置的内容，在python中是没有办法直接实现的，如果想要实现这样的操作只能先把文件所有的内容全部读取出来，然后进行匹配修改后写入到新的文件中。实例代码如下所示： # 打开旧文件f = open(‘file_text.txt’,’r’,encoding=’utf-8’)、# 打开新文件f_new = open(‘file_text_bak.txt’,’w’,encoding=’utf-8’) # 循环读取旧文件for line in f: # 进行判断 if &quot;Good day is good day&quot; in line: line = line.replace(&apos;Good day is good day&apos;,&apos;hello,yanyan&apos;) # 如果不符合就正常的将文件中的内容读取并且输出到新文件中 f_new.write(line) f.close()f_new.close() 5 开启库手册服务python -m pydoc -p 8888 6 讲上级目录的的raw生成bmp（例）123456789101112131415161718192021222324252627282930# -*- coding: utf-8 -*-import osimport shutilimg_path = os.path.abspath('..')result_path = img_path+"\\raw\\"imgs = []old_pic = []for root, dirs, files in os.walk(result_path): for file in files: if os.path.splitext(file)[1] == ".raw": print("2"+file) os.remove(os.path.join(root, file))#删除文件for root, dirs, files in os.walk(img_path): for file in files: if os.path.splitext(file)[1] == ".raw": imgs.append(os.path.join(root, file)) print("0"+file) if os.path.splitext(file)[1] == ".bmp": os.remove(os.path.join(root, file)) print("1"+file)for img in imgs: print(r".\raw_to_bmp_node.exe --img_fname=%s --width=%d --height=%d" % (img, 1280, 800)) os.system(r".\raw_to_bmp_node.exe --img_fname=%s --width=%d --height=%d" % (img, 1280, 800)) shutil.move(img, result_path+os.path.basename(img)) #os.remove(img) 7 python 读写、创建 文件python中对文件、文件夹（文件操作函数）的操作需要涉及到os模块和shutil模块。 得到当前工作目录，即当前Python脚本工作的目录路径: os.getcwd() 返回指定目录下的所有文件和目录名:os.listdir() 函数用来删除一个文件:os.remove() 删除多个目录：os.removedirs（r“c：\python”） 检验给出的路径是否是一个文件：os.path.isfile() 检验给出的路径是否是一个目录：os.path.isdir() 判断是否是绝对路径：os.path.isabs() 检验给出的路径是否真地存:os.path.exists() 返回一个路径的目录名和文件名:os.path.split() eg os.path.split(‘/home/swaroop/byte/code/poem.txt’) 结果：(‘/home/swaroop/byte/code’, ‘poem.txt’) 分离扩展名：os.path.splitext() 获取路径名：os.path.dirname() 获取文件名：os.path.basename() 运行shell命令: os.system() 读取和设置环境变量:os.getenv() 与os.putenv() 给出当前平台使用的行终止符:os.linesep Windows使用’\r\n’，Linux使用’\n’而Mac使用’\r’ 指示你正在使用的平台：os.name 对于Windows，它是’nt’，而对于Linux/Unix用户，它是’posix’ 重命名：os.rename（old， new） 创建多级目录：os.makedirs（r“c：\python\test”） 创建单个目录：os.mkdir（“test”） 获取文件属性：os.stat（file） 修改文件权限与时间戳：os.chmod（file） 终止当前进程：os.exit（） 获取文件大小：os.path.getsize（filename） 文件操作：os.mknod(“test.txt”) 创建空文件fp = open(“test.txt”,w) 直接打开一个文件，如果文件不存在则创建文件 关于open 模式： w 以写方式打开，a 以追加模式打开 (从 EOF 开始, 必要时创建新文件)r+ 以读写模式打开w+ 以读写模式打开 (参见 w )a+ 以读写模式打开 (参见 a )rb 以二进制读模式打开wb 以二进制写模式打开 (参见 w )ab 以二进制追加模式打开 (参见 a )rb+ 以二进制读写模式打开 (参见 r+ )wb+ 以二进制读写模式打开 (参见 w+ )ab+ 以二进制读写模式打开 (参见 a+ ) fp.read([size]) #size为读取的长度，以byte为单位 fp.readline([size]) #读一行，如果定义了size，有可能返回的只是一行的一部分 fp.readlines([size]) #把文件每一行作为一个list的一个成员，并返回这个list。其实它的内部是通过循环调用readline()来实现的。如果提供size参数，size是表示读取内容的总长，也就是说可能只读到文件的一部分。 fp.write(str) #把str写到文件中，write()并不会在str后加上一个换行符 fp.writelines(seq) #把seq的内容全部写到文件中(多行一次性写入)。这个函数也只是忠实地写入，不会在每行后面加上任何东西。 fp.close() #关闭文件。python会在一个文件不用后自动关闭文件，不过这一功能没有保证，最好还是养成自己关闭的习惯。 如果一个文件在关闭后还对其进行操作会产生ValueError fp.flush() #把缓冲区的内容写入硬盘 fp.fileno() #返回一个长整型的”文件标签“ fp.isatty() #文件是否是一个终端设备文件（unix系统中的） fp.tell() #返回文件操作标记的当前位置，以文件的开头为原点 fp.next() #返回下一行，并将文件操作标记位移到下一行。把一个file用于for … in file这样的语句时，就是调用next()函数来实现遍历的。 fp.seek(offset[,whence]) #将文件打操作标记移到offset的位置。这个offset一般是相对于文件的开头来计算的，一般为正数。但如果提供了whence参数就不一定了，whence可以为0表示从头开始计算，1表示以当前位置为原点计算。2表示以文件末尾为原点进行计算。需要注意，如果文件以a或a+的模式打开，每次进行写操作时，文件操作标记会自动返回到文件末尾。 fp.truncate([size]) #把文件裁成规定的大小，默认的是裁到当前文件操作标记的位置。如果size比文件的大小还要大，依据系统的不同可能是不改变文件，也可能是用0把文件补到相应的大小，也可能是以一些随机的内容加上去。 目录操作：os.mkdir(“file”) 创建目录复制文件：shutil.copyfile(“oldfile”,”newfile”) oldfile和newfile都只能是文件shutil.copy(“oldfile”,”newfile”) oldfile只能是文件夹，newfile可以是文件，也可以是目标目录复制文件夹：shutil.copytree(“olddir”,”newdir”) olddir和newdir都只能是目录，且newdir必须不存在重命名文件（目录）os.rename(“oldname”,”newname”) 文件或目录都是使用这条命令移动文件（目录）shutil.move(“oldpos”,”newpos”)删除文件os.remove(“file”)删除目录os.rmdir(“dir”)只能删除空目录shutil.rmtree(“dir”) 空目录、有内容的目录都可以删转换目录os.chdir(“path”) 换路径 Python读写文件1.open使用open打开文件后一定要记得调用文件对象的close()方法。比如可以用try/finally语句来确保最后能关闭文件。 file_object = open(‘thefile.txt’)try: all_the_text = file_object.read( )finally: file_object.close( ) 注：不能把open语句放在try块里，因为当打开文件出现异常时，文件对象file_object无法执行close()方法。 2.读文件123456789101112131415161718192021222324252627282930313233读文本文件input = open(&apos;data&apos;, &apos;r&apos;)#第二个参数默认为rinput = open(&apos;data&apos;) 读二进制文件input = open(&apos;data&apos;, &apos;rb&apos;)读取所有内容file_object = open(&apos;thefile.txt&apos;)try: all_the_text = file_object.read( )finally: file_object.close( )读固定字节file_object = open(&apos;abinfile&apos;, &apos;rb&apos;)try: while True: chunk = file_object.read(100) if not chunk: break do_something_with(chunk)finally: file_object.close( )读每行list_of_all_the_lines = file_object.readlines( )如果文件是文本文件，还可以直接遍历文件对象获取每行：for line in file_object: process line 3.写文件写文本文件output = open(‘data’, ‘w’) 写二进制文件output = open(‘data’, ‘wb’) 追加写文件output = open(‘data’, ‘w+’) 写数据file_object = open(‘thefile.txt’, ‘w’)file_object.write(all_the_text)file_object.close( ) 写入多行file_object.writelines(list_of_text_strings) 注意，调用writelines写入多行在性能上会比使用write一次性写入要高。 在处理日志文件的时候，常常会遇到这样的情况：日志文件巨大，不可能一次性把整个文件读入到内存中进行处理，例如需要在一台物理内存为 2GB 的机器上处理一个 2GB 的日志文件，我们可能希望每次只处理其中 200MB 的内容。在 Python 中，内置的 File 对象直接提供了一个 readlines(sizehint) 函数来完成这样的事情。以下面的代码为例： file = open(‘test.log’, ‘r’)sizehint = 209715200 # 200Mposition = 0lines = file.readlines(sizehint)while not file.tell() - position &lt; 0: position = file.tell() lines = file.readlines(sizehint) 每次调用 readlines(sizehint) 函数，会返回大约 200MB 的数据，而且所返回的必然都是完整的行数据，大多数情况下，返回的数据的字节数会稍微比 sizehint 指定的值大一点（除最后一次调用 readlines(sizehint) 函数的时候）。通常情况下，Python 会自动将用户指定的 sizehint 的值调整成内部缓存大小的整数倍。 file在python是一个特殊的类型，它用于在python程序中对外部的文件进行操作。在python中一切都是对象，file也不例外，file有file的方法和属性。下面先来看如何创建一个file对象： file(name[, mode[, buffering]])file()函数用于创建一个file对象，它有一个别名叫open()，可能更形象一些，它们是内置函数。来看看它的参数。它参数都是以字符串的形式传递的。name是文件的名字。mode是打开的模式，可选的值为r w a U，分别代表读（默认） 写 添加支持各种换行符的模式。用w或a模式打开文件的话，如果文件不存在，那么就自动创建。此外，用w模式打开一个已经存在的文件时，原有文件的内容会被清空，因为一开始文件的操作的标记是在文件的开头的，这时候进行写操作，无疑会把原有的内容给抹掉。由于历史的原因，换行符在不同的系统中有不同模式，比如在 unix中是一个\n，而在windows中是‘\r\n’，用U模式打开文件，就是支持所有的换行模式，也就说‘\r’ ‘\n’ ‘\r\n’都可表示换行，会有一个tuple用来存贮这个文件中用到过的换行符。不过，虽说换行有多种模式，读到python中统一用\n代替。在模式字符的后面，还可以加上+ b t这两种标识，分别表示可以对文件同时进行读写操作和用二进制模式、文本模式（默认）打开文件。buffering如果为0表示不进行缓冲;如果为1表示进行“行缓冲“;如果是一个大于1的数表示缓冲区的大小，应该是以字节为单位的。 file对象有自己的属性和方法。先来看看file的属性。 closed #标记文件是否已经关闭，由close()改写encoding #文件编码mode #打开模式name #文件名newlines #文件中用到的换行模式，是一个tuplesoftspace #boolean型，一般为0，据说用于print file的读写方法： 12345678910111213141516171819202122232425262728F.read([size]) #size为读取的长度，以byte为单位 F.readline([size]) #读一行，如果定义了size，有可能返回的只是一行的一部分 F.readlines([size]) #把文件每一行作为一个list的一个成员，并返回这个list。其实它的内部是通过循环调用readline()来实现的。如果提供size参数，size是表示读取内容的总长，也就是说可能只读到文件的一部分。 F.write(str) #把str写到文件中，write()并不会在str后加上一个换行符 F.writelines(seq) #把seq的内容全部写到文件中。这个函数也只是忠实地写入，不会在每行后面加上任何东西。 file的其他方法：F.close() #关闭文件。python会在一个文件不用后自动关闭文件，不过这一功能没有保证，最好还是养成自己关闭的习惯。如果一个文件在关闭后还对其进行操作会产生ValueError F.flush() #把缓冲区的内容写入硬盘 F.fileno() #返回一个长整型的”文件标签“ F.isatty() #文件是否是一个终端设备文件（unix系统中的） F.tell() #返回文件操作标记的当前位置，以文件的开头为原点 F.next() #返回下一行，并将文件操作标记位移到下一行。把一个file用于for ... in file这样的语句时，就是调用next()函数来实现遍历的。 F.seek(offset[,whence]) #将文件打操作标记移到offset的位置。这个offset一般是相对于文件的开头来计算的，一般为正数。但如果提供了whence参数就不一定了，whence可以为0表示从头开始计算，1表示以当前位置为原点计算。2表示以文件末尾为原点进行计算。需要注意，如果文件以a或a+的模式打开，每次进行写操作时，文件操作标记会自动返回到文件末尾。 F.truncate([size]) #把文件裁成规定的大小，默认的是裁到当前文件操作标记的位置。如果size比文件的大小还要大，依据系统的不同可能是不改变文件，也可能是用0把文件补到相应的大小，也可能是以一些随机的内容加上去。 http://www.cnblogs.com/allenblogs/archive/2010/09/13/1824842.html http://www.cnblogs.com/rollenholt/archive/2012/04/23/2466179.html 收获不会与付出成反比 by juandx 8Python 截取字符串使用 变量[头下标:尾下标]，就可以截取相应的字符串，其中下标是从0开始算起，可以是正数或负数，下标可以为空表示取到头或尾。 123456789101112131415161718192021222324252627282930313233例1：字符串截取str = '12345678'print str[0:1]&gt;&gt; 1 # 输出str位置0开始到位置1以前的字符print str[1:6] &gt;&gt; 23456 # 输出str位置1开始到位置6以前的字符num = 18str = '0000' + str(num) # 合并字符串print str[-5:] # 输出字符串右5位&gt;&gt; 00018 Python 替换字符串使用 变量.replace("被替换的内容"，"替换后的内容"[，次数])，替换次数可以为空，即表示替换所有。要注意的是使用replace替换字符串后仅为临时变量，需重新赋值才能保存。#例2：字符串替换str = 'akakak'str = str.replace('k',' 8') # 将字符串里的k全部替换为8print str&gt;&gt; 'a8a8a8' # 输出结果Python 查找字符串使用 变量.find("要查找的内容"[，开始位置，结束位置])，开始位置和结束位置，表示要查找的范围，为空则表示查找所有。查找到后会返回位置，位置从0开始算，如果每找到则返回-1。#例3：字符串查找str = 'a,hello'print str.find('hello') # 在字符串str里查找字符串hello&gt;&gt; 2 # 输出结果Python 分割字符串使用 变量.split("分割标示符号"[分割次数])，分割次数表示分割最大次数，为空则分割所有。例4：字符分割str = 'a,b,c,d'strlist = str.split(',') # 用逗号分割str字符串，并保存到列表for value in strlist: # 循环输出列表值 print value&gt;&gt; a # 输出结果&gt;&gt; b&gt;&gt; c&gt;&gt; d =============================================================================== 123456789101112131415161718192021222324mport tkinter.filedialog as tkFDdef __init__(self, root): self.ext1 = Button(self.frame[1], text="选择文件", command=self.openfile,width = 10) self.ext1.pack(side = LEFT, padx = 2,pady = 10) self.txt = Text(self.frame[1],height = 1,width = 80) self.txt.pack(side = LEFT, padx = 2,pady = 10) self.ext3 = Button(self.frame[3], text="选择根目录", command=self.opendir,width = 10) self.ext3.pack(side = LEFT, padx = 2,pady = 10) self.path = Text(self.frame[3],height = 1,width = 40) self.path.pack(side = LEFT, padx = 2,pady = 10)def openfile(self): self.filename=tkFD.askopenfilename(filetypes=[("Excel 工作簿", ".xls")]) self.txt.delete(1.0,END) self.txt.insert(1.0,self.filename) def opendir(self): self.pathname=tkFD.askdirectory() self.path.delete(1.0,END) self.path.insert(1.0,self.pathname) 9 打包exe1pyinstaller -F tools2.py --noconsole 或者 1pyinstaller -F -w example.py 直接打包： 1pyinstaller -F -w example.py 10result = os.popen(‘ps aux’) res = result.read() for line in res.splitlines(): print line 11 配置文件inihttps://blog.csdn.net/zhusongziye/article/details/80024530https://blog.csdn.net/energysober/article/details/80684200 #12 读写excel https://www.cnblogs.com/shaosks/p/6098282.htmlhttps://www.cnblogs.com/lingwang3/p/6416023.html TK颜色https://blog.csdn.net/Gordennizaicunzai/article/details/81148670http://www.qhscript.com/index.php?c=article&amp;id=299https://blog.csdn.net/lqxkj628/article/details/76541287 #TK Text https://blog.csdn.net/sinat_41104353/article/details/79307111]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
</search>
